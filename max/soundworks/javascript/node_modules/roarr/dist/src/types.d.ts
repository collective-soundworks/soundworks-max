/// <reference types="node" />
import type { AsyncLocalStorage } from 'async_hooks';
export declare type JsonValue = JsonObject | JsonValue[] | boolean | number | string | null | undefined;
export declare type JsonObject = {
    [k: string]: JsonValue;
};
export declare type LogWriter = (message: string) => void;
export declare type MessageContext<T = {}> = JsonObject & T;
export declare type TopLevelAsyncLocalContext = {
    messageContext: MessageContext;
    transforms: ReadonlyArray<TransformMessageFunction<MessageContext>>;
};
export declare type NestedAsyncLocalContext = TopLevelAsyncLocalContext & {
    sequence: number;
    sequenceRoot: string;
};
export declare type AsyncLocalContext = NestedAsyncLocalContext | TopLevelAsyncLocalContext;
export declare type MessageSerializer = (message: Message<MessageContext>) => string;
export declare type RoarrGlobalState = {
    asyncLocalStorage?: AsyncLocalStorage<AsyncLocalContext>;
    sequence: number;
    serializeMessage?: MessageSerializer;
    versions: readonly string[];
    write: LogWriter;
};
export declare type SprintfArgument = boolean | number | string | null;
export declare type Message<T = MessageContext> = {
    readonly context: T;
    readonly message: string;
    readonly sequence: string;
    readonly time: number;
    readonly version: string;
};
export declare type TransformMessageFunction<T> = (message: Message<T>) => Message<MessageContext>;
export declare type LogMethod<Z> = {
    <T extends string = string>(context: Z, message: T, c?: T extends `${string}%${string}` ? SprintfArgument : never, d?: SprintfArgument, e?: SprintfArgument, f?: SprintfArgument, g?: SprintfArgument, h?: SprintfArgument, i?: SprintfArgument, j?: SprintfArgument): void;
    <T extends string = string>(message: T, b?: T extends `${string}%${string}` ? SprintfArgument : never, c?: SprintfArgument, d?: SprintfArgument, e?: SprintfArgument, f?: SprintfArgument, g?: SprintfArgument, h?: SprintfArgument, i?: SprintfArgument, j?: SprintfArgument): void;
};
declare type Child<Z> = {
    <T = Z>(context: TransformMessageFunction<MessageContext<T>>): Logger<T | Z>;
    (context: MessageContext): Logger<Z>;
};
export declare type Logger<Z = MessageContext> = LogMethod<Z> & {
    adopt: <T>(routine: () => T, context?: MessageContext | TransformMessageFunction<MessageContext>) => Promise<T>;
    child: Child<Z>;
    debug: LogMethod<Z>;
    error: LogMethod<Z>;
    fatal: LogMethod<Z>;
    getContext: () => MessageContext;
    info: LogMethod<Z>;
    trace: LogMethod<Z>;
    warn: LogMethod<Z>;
};
export declare type MessageEventHandler = (message: Message<MessageContext>) => void;
export declare type LogLevelName = 'trace' | 'debug' | 'info' | 'error' | 'fatal' | 'warn';
export {};
